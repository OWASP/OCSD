Following are the modules that the working group for OCSD has arrived at:

Modules:
1. Secure Architecture and Threat Modelling
2. Authentication and Credential Management 
3. Authorisation 
4. Input Validation and Output Encoding 
5. Cryptography and Key Management
6. Error Handling
7. Secure Logging
8. Data Protection and Privacy
9. Secure Communications
10. Malicious Code and Software Supply Chain Security including usage of open source software
11. Business Logic Security
12. Secure File and Resource Handling
13. API and Web Service Security
14. Secure Configuration and Deployment
15. Security of and for AI

Below is a more detailed view of the modules

Module 1: Secure Architecture and Threat Modeling\
  &nbsp; &nbsp; &nbsp; &nbsp; STRIDE, DREAD, LINDDUN\
  &nbsp; &nbsp; &nbsp; &nbsp; Data Flow Diagrams (DFDs)\
  &nbsp; &nbsp; &nbsp; &nbsp; Trust boundaries\
  &nbsp; &nbsp; &nbsp; &nbsp; Secure SDLC practices\
  &nbsp; &nbsp; &nbsp; &nbsp; Common design flaws

Module 2: Authentication and Credential Management\
  &nbsp; &nbsp; &nbsp; &nbsp; MFA implementation\
  &nbsp; &nbsp; &nbsp; &nbsp; Secure password storage (hashing/salting)\
  &nbsp; &nbsp; &nbsp; &nbsp; Authenticator lifecycle (provisioning, rotation, expiration)\
  &nbsp; &nbsp; &nbsp; &nbsp; OAuth2, OIDC, SAML basics\
  &nbsp; &nbsp; &nbsp; &nbsp; Credential recovery securely

Module 3: Authorisation\
  &nbsp; &nbsp; &nbsp; &nbsp; Session timeout, renewal\
  &nbsp; &nbsp; &nbsp; &nbsp; Cookie attributes: Secure, HttpOnly, SameSite\
  &nbsp; &nbsp; &nbsp; &nbsp; Token vs cookie-based sessions\
  &nbsp; &nbsp; &nbsp; &nbsp; Logout and re-authentication\
  &nbsp; &nbsp; &nbsp; &nbsp; Fixation and hijacking defenses\
  &nbsp; &nbsp; &nbsp; &nbsp; RBAC vs ABAC\
  &nbsp; &nbsp; &nbsp; &nbsp; Object-level authorization\
  &nbsp; &nbsp; &nbsp; &nbsp; Security of authorisation tokens (JWT etc)\
  &nbsp; &nbsp; &nbsp; &nbsp; Horizontal vs vertical privilege escalation\
  &nbsp; &nbsp; &nbsp; &nbsp; Testing access control effectively

Module 4: Input Validation and Output Encoding\
  &nbsp; &nbsp; &nbsp; &nbsp; Positive (whitelist) validation\
  &nbsp; &nbsp; &nbsp; &nbsp; Output encoding: HTML, JS, SQL\
  &nbsp; &nbsp; &nbsp; &nbsp; Server-side vs client-side validation\
  &nbsp; &nbsp; &nbsp; &nbsp; Injection attacks (SQL, SSI, OS, LDAP, XXE, XPath)

## Module 5: Cryptography and Key Management

### Common algorithm pitfalls  

* Always use Authenticated Encryption (AEAD)
* Know what AEAD is
* Know common examples of AEAD modes (GCM, CCM, OCB, Chacha20-Poly1305)
* Prefer integrated AEAD modes over custom-built
* When doing AEAD manually, use Encrypt-then-MAC
* Prefer ChaCha20 on lightweight/embedded devices over AES
* Nonce must be unique per key and plaintext combination
* Never use a static nonce
* An Initialization Vector (IV) needs to be unpredictable (=random)
* Nonce and IV don't need to be secret
* Do not use symmetric keys < 128 bit
* Do not use Hash Algorithms older that SHA-2
* Use HMAC when requiring a MAC, nothing custom-built
* Use OEAP (=PKCS#1 v2.0) mode when doing RSA encryption
* Use PSS (=PKCS#1 v2.1) model when doing RSA signatures
* Do not reuse keys for multiple purposes
* Use dedicated schemes for password hashing, not standard hash functions like SHA-2
* Parameters for password-hashes need to be adapted regularly according to industry recommendations
* Always use a salt when hashing passwords
* Salt does not have to be secret
* Salt has to be unique per user
* Base64 is no encryption algorithm
* Do not use cipher suites with CBC, RSA, (3)DES in TLS, harden against industry recommendations (e.g., Mozilla)
Â 
### Secure random number generation

* Pseudo Random Number Generators (PRNG) produce deterministic output
* A PRNG needs to be seeded with actual random numbers
* A PRNG needs to be re-seeded periodically
* True Random Number Generators (TRNG) use physical observations to produce random numbers
* TRNGs are too slow for actual usage
* Always use a Cryptographically Secure Pseudo Random Number Generator (CSPRNG) when doing security-relevant things
* Operating Systems provide secure APIs for generating secure Random numbers. Those should be the preferred way of generating random numbers. 
* The OS takes care of seeding and re-seeding its CSPRNG automatically
* Use /dev/urandom on Unix-based systems
* Use BCryptGenRandom() on Windows
* Most development Frameworks offer an API with a CSPRNG; they usually have "Secure" or "Crypto" in its name
* The Framework takes care of seeding and re-seeding its CSPRNG automatically
* Do not use RNG APIs without "Secure" or "Crypto" in its name
* A well seeded CSRPNG can produce unlimited output

### Key lifecycle and storage

* Base64 encoded keys are not encrypted
* Make sure to set file ACL appropriately when storing a secret key in a file
* Prefer using OS-API for key management to doing this manually
*  Secret keys stored in a file should preferably be encrypted with a key derived from a user-supplied password
* Secret keys from a hardware token can usually not be exported
* Secret keys generated on a hardware token won't have a backup available
* All keys should have a well-defined lifetime and be rotated at the end of the lifetime
* Common lifetimes for certain key sizes can be found in industry recommendations
* The more often a key is used, the shorter its lifetime should be
* The shorter the size of a key, the shorter its lifetime should be
* Access to a key needs to be restricted according to the principle of least privilege
* When rotating a symmetric key, all data encrypted with the old key needs to be re-encrypted

### Digital signatures and HMACs

* MACs are symmetric algorithm
* Digital signatures are asymmetric algorithms
* When using a MAC, everyone who can verify a signature can also create one
* When using a digital signature, people who can verify a signature cannot create one
* A digital signature is created with a private key
* A digital signature is verified with a public key
* A MAC is created with a secret key
* A MAC is verified with a secret key
* MACs are faster the digital signatures
* Always verify the signature before using the signed data
* Elliptic curve based schemes have smaller key- and signature-sizes than RSA
* Prefer Ed25519 (EdDSA) over ECDSA
* (X.509) certificates combine a public key with metadata about the key's owner
* (X.509) certificates are digitally signed by a trusted entity
* X.509 certificates are digitally signed by Certification Authority (CA)

Module 6: Error Handling\
  &nbsp; &nbsp; &nbsp; &nbsp; Logging sensitive operations securely\
  &nbsp; &nbsp; &nbsp; &nbsp; Avoiding stack traces/info leaks

Module 7: Secure Logging\
  &nbsp; &nbsp; &nbsp; &nbsp; Log protection (tamper resistance)\
  &nbsp; &nbsp; &nbsp; &nbsp; Real-time alerting and monitoring

Module 8: Data Protection and Privacy\
  &nbsp; &nbsp; &nbsp; &nbsp; TLS enforcement\
  &nbsp; &nbsp; &nbsp; &nbsp; Client-side storage threats\
  &nbsp; &nbsp; &nbsp; &nbsp; GDPR/CCPA considerations\
  &nbsp; &nbsp; &nbsp; &nbsp; Data retention and purging\
  &nbsp; &nbsp; &nbsp; &nbsp; Caching and privacy headers

Module 9: Secure Communications\
  &nbsp; &nbsp; &nbsp; &nbsp; TLS 1.2+ best practices\
  &nbsp; &nbsp; &nbsp; &nbsp; HTTPS and HSTS\
  &nbsp; &nbsp; &nbsp; &nbsp; Certificate pinning\
  &nbsp; &nbsp; &nbsp; &nbsp; Secure protocol selection

Module 10: Malicious Code, Supply Chain and Open Source Software\
  &nbsp; &nbsp; &nbsp; &nbsp; Dependency management (SCA tools like OWASP Dependency-Check)\
  &nbsp; &nbsp; &nbsp; &nbsp; Secure deserialization\
  &nbsp; &nbsp; &nbsp; &nbsp; Subdomain takeover\
  &nbsp; &nbsp; &nbsp; &nbsp; Code signing and verification\
  &nbsp; &nbsp; &nbsp; &nbsp; Open source software and licensing

Module 11: Business Logic Security\
  &nbsp; &nbsp; &nbsp; &nbsp; Logical flaws (race conditions, inconsistent state)\
  &nbsp; &nbsp; &nbsp; &nbsp; Anti-automation (CAPTCHA, rate limiting)\
  &nbsp; &nbsp; &nbsp; &nbsp; Anomaly detection and misuse cases

Module 12: Secure File and Resource Handling\
  &nbsp; &nbsp; &nbsp; &nbsp; Upload/download controls\
  &nbsp; &nbsp; &nbsp; &nbsp; Path traversal\
  &nbsp; &nbsp; &nbsp; &nbsp; RFI, SSRF protections\
  &nbsp; &nbsp; &nbsp; &nbsp; MIME sniffing and validation

Module 13: API and Web Service Security\
  &nbsp; &nbsp; &nbsp; &nbsp; REST, GraphQL, and SOAP security models\
  &nbsp; &nbsp; &nbsp; &nbsp; Authentication and authorization for APIs\
  &nbsp; &nbsp; &nbsp; &nbsp; Throttling and abuse protection\
  &nbsp; &nbsp; &nbsp; &nbsp; JSON and XML parser safety

Module 14: Secure Configuration and Deployment\
  &nbsp; &nbsp; &nbsp; &nbsp; Secure defaults\
  &nbsp; &nbsp; &nbsp; &nbsp; Secrets management (vaults, env vars)\
  &nbsp; &nbsp; &nbsp; &nbsp; CORS, CSP, HSTS\
  &nbsp; &nbsp; &nbsp; &nbsp; SBOM and CI/CD hardening

Module 15: Security of and for AI\
  &nbsp; &nbsp; &nbsp; &nbsp; Securing models\
  &nbsp; &nbsp; &nbsp; &nbsp; Securing datasets 
