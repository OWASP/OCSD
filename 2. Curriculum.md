Following are the modules that the working group for OCSD has arrived at:

Modules:

1. Secure Architecture and Threat Modelling
2. Authentication and Credential Management
3. Authorisation
4. Input Validation and Output Encoding
5. Cryptography and Key Management
6. Error Handling
7. Secure Logging
8. Data Protection and Privacy
9. Secure Communications
10. Malicious Code and Software Supply Chain Security including usage of open source software
11. Business Logic Security
12. Secure File and Resource Handling
13. API and Web Service Security
14. Secure Configuration and Deployment
15. Security of and for AI

Below is a more detailed view of the modules

## Module 1: Secure Architecture and Threat Modeling  
        STRIDE, DREAD, LINDDUN  
        Data Flow Diagrams (DFDs)  
        Trust boundaries  
        Secure SDLC practices  
        Common design flaws

## Module 2: Authentication and Credential Management  

##### Secure Password Storage

* Never store passwords in plaintext. All passwords must be stored as one-way cryptographic hashes.
* Use a strong, modern password hashing algorithm. Prefer algorithms specifically designed for password hashing, such as Argon2, scrypt, or bcrypt.
* Avoid outdated or weak hashing algorithms. Do not use generic hash functions like MD5 or SHA-256 for password storage, as they are too fast and susceptible to brute-force attacks.
* Salt every password with a unique, random salt. A salt is a random string added to a password before hashing. A unique salt for each user prevents attackers from using pre-computed rainbow tables and ensures that two users with the same password have different hashes.
* Adjust the cost factor of the hashing algorithm. Password hashing algorithms are designed to be computationally expensive. The cost factor should be increased over time as computing power improves to maintain resistance against brute-force attacks.



##### Multi-Factor Authentication (MFA)

* Implement MFA for all users, especially for privileged accounts. MFA requires users to provide two or more verification factors, such as:

&nbsp;	- Something you know (a password)

&nbsp;	- Something you have (a phone or hardware token)

&nbsp;	- Something you are (biometrics like a fingerprint)

* Prioritize strong MFA methods.

&nbsp;	- Hardware security tokens (FIDO2/WebAuthn) are considered the gold standard as they are resistant to phishing.

&nbsp;	- Authenticator apps using Time-based One-Time Passwords (TOTP) are a secure and widely adopted method.

&nbsp;	- Push notifications from a trusted app are generally more user-friendly and secure than SMS.

* Use SMS-based MFA with caution. While better than no MFA, SMS can be vulnerable to SIM swapping attacks. Use it as a last resort or a temporary fallback.
* Securely implement the MFA enrollment and recovery processes. MFA recovery should be as secure as initial authentication to prevent account takeovers.



##### Credential Lifecycle Management

* Credential Provisioning: When a new user is created, enforce a strong password policy with complexity requirements. Use a trusted password generator for initial password creation where possible.
* Credential Rotation:

&nbsp;	- While mandatory, frequent password expiration is no longer considered a best practice, as it can lead to users choosing simpler passwords.

&nbsp;	- Focus on detecting compromised credentials and requiring a password change only when a compromise is suspected.

* Credential Revocation: Have a clear, automated process to immediately revoke credentials when an employee leaves or an account is compromised.
* Secure Credential Recovery:

&nbsp;	- Avoid sending plaintext passwords. Instead, send a secure, one-time link to a user's verified email to allow them to reset their password.

&nbsp;	- Expire password reset links quickly (e.g., after 15 minutes).

&nbsp;	- Rate-limit password recovery attempts to prevent automated attacks.



##### Federation and Single Sign-On (SSO)

* Understand the difference between authentication and authorization. Authentication is verifying a user's identity. Authorization is determining what that user is allowed to do.
* OAuth 2.0 is an authorization framework. It allows an application to get limited access to a user's account on another service without knowing their password.
* OpenID Connect (OIDC) is an authentication layer built on top of OAuth 2.0. It is used to verify the user's identity and obtain basic profile information.
* SAML (Security Assertion Markup Language) is another standard for authentication and authorization, often used for enterprise SSO solutions.
* When implementing these protocols, always use a well-vetted, official library. Do not try to implement these complex protocols from scratch.
* Validate tokens and assertions. Always verify the digital signature, issuer, audience, and expiration of tokens (e.g., JSON Web Tokens) to ensure they are legitimate.
* Use the state parameter. This parameter should be used to protect against Cross-Site Request Forgery (CSRF) attacks when redirecting users.

##### 





## Module 3: Authorisation  
        Session timeout, renewal  
        Cookie attributes: Secure, HttpOnly, SameSite  
        Token vs cookie-based sessions  
        Logout and re-authentication  
        Fixation and hijacking defenses  
        RBAC vs ABAC  
        Object-level authorization  
        Security of authorisation tokens (JWT etc)  
        Horizontal vs vertical privilege escalation  
        Testing access control effectively

## Module 4: Input Validation and Output Encoding  

##### Input Validation Principles

* Always use Positive (Whitelist) Validation

&nbsp;	- Explicitly define what is allowed and reject everything else.

&nbsp;	- Do not attempt to filter out "bad" data (negative validation), as attackers will find ways to bypass your filters.

* Never trust client-side validation for security.

&nbsp;	- Use client-side validation for a better user experience (UX) but understand it can be easily bypassed.

&nbsp;	- All security-critical validation must happen on the server.

* Validate all input sources, not just form fields.

&nbsp;	- This includes URL parameters, HTTP headers, cookies, file uploads, and data from APIs.

* Enforce strict data constraints.

&nbsp;	- Check for the expected data type (e.g., integer, string, date).

&nbsp;	- Enforce a maximum and minimum length for strings.

&nbsp;	- Validate the format of the data (e.g., a regex for an email address).

* Reject invalid input early.

&nbsp;	- If input fails validation, reject it immediately and provide a generic error message. Do not process it further.

* Use a trusted validation library.

&nbsp;	- Avoid writing your own validation logic from scratch. Use a well-tested library from your chosen framework.



##### Output Encoding and Sanitization

* Encode all user-supplied data before rendering it.

&nbsp;	- This prevents the browser from interpreting the data as code.

* Use context-specific encoding.

&nbsp;	- For HTML: Convert special characters like <, >, \&, ", and ' to their HTML entity equivalents (\&lt;, \&gt;, \&amp;, etc.). This prevents XSS attacks.

&nbsp;	- For JavaScript: Escape all user input if it's being placed inside a script block.

&nbsp;	- For SQL: The most secure method is to use parameterized queries. If this is not an option, use the database driver's specific escape function, but this is a last resort.

* Sanitize data for rich content

&nbsp;	- If you allow users to input rich HTML, use a dedicated HTML sanitizer library to remove dangerous tags and attributes.

* Do not rely on a single encoding function for all contexts.

&nbsp;	- A function for HTML encoding is not safe for JavaScript, and vice-versa.

* Use a secure encoding library.

&nbsp;	- Modern frameworks provide built-in functions for safe encoding.



##### Preventing Injection Attacks

* SQL Injection:

&nbsp;	- Always use parameterized queries or prepared statements.

&nbsp;	- Never build a SQL query by concatenating strings with user input.

* OS Command Injection:

&nbsp;	- Do not pass user-supplied data to system commands.

&nbsp;	- If a command must be run, use a dedicated, safe API and a whitelist of allowed commands and parameters.

* XXE (XML External Entity) Injection:

&nbsp;	- Disable DTDs and external entities in your XML parsers by default.

* LDAP Injection:

&nbsp;	- Sanitize or escape all user input before it is used in an LDAP search filter.

&nbsp;	- Use an API that supports parameterized queries for LDAP if available.

* SSI (Server-Side Includes) Injection:

&nbsp;	- Disable Server-Side Includes if you don't need them.

&nbsp;	- If they are necessary, ensure no user input can influence the directives.

* XPath Injection:

&nbsp;	- Use a dedicated XPath API that handles parameters securely instead of building XPath queries with string concatenation.





## Module 5: Cryptography and Key Management

### Common algorithm pitfalls

* Always use Authenticated Encryption (AEAD)
* Know what AEAD is
* Know common examples of AEAD modes (GCM, CCM, OCB, Chacha20-Poly1305)
* Prefer integrated AEAD modes over custom-built
* When doing AEAD manually, use Encrypt-then-MAC
* Prefer ChaCha20 on lightweight/embedded devices over AES
* Nonce must be unique per key and plaintext combination
* Never use a static nonce
* An Initialization Vector (IV) needs to be unpredictable (=random)
* Nonce and IV don't need to be secret
* Do not use symmetric keys < 128 bit
* Do not use Hash Algorithms older that SHA-2
* Use HMAC when requiring a MAC, nothing custom-built
* Use OEAP (=PKCS#1 v2.0) mode when doing RSA encryption
* Use PSS (=PKCS#1 v2.1) model when doing RSA signatures
* Do not reuse keys for multiple purposes
* Use dedicated schemes for password hashing, not standard hash functions like SHA-2
* Parameters for password-hashes need to be adapted regularly according to industry recommendations
* Always use a salt when hashing passwords
* Salt does not have to be secret
* Salt has to be unique per user
* Base64 is no encryption algorithm
* Do not use cipher suites with CBC, RSA, (3)DES in TLS, harden against industry recommendations (e.g., Mozilla)
   

### Secure random number generation

* Pseudo Random Number Generators (PRNG) produce deterministic output
* A PRNG needs to be seeded with actual random numbers
* A PRNG needs to be re-seeded periodically
* True Random Number Generators (TRNG) use physical observations to produce random numbers
* TRNGs are too slow for actual usage
* Always use a Cryptographically Secure Pseudo Random Number Generator (CSPRNG) when doing security-relevant things
* Operating Systems provide secure APIs for generating secure Random numbers. Those should be the preferred way of generating random numbers.
* The OS takes care of seeding and re-seeding its CSPRNG automatically
* Use /dev/urandom on Unix-based systems
* Use BCryptGenRandom() on Windows
* Most development Frameworks offer an API with a CSPRNG; they usually have "Secure" or "Crypto" in its name
* The Framework takes care of seeding and re-seeding its CSPRNG automatically
* Do not use RNG APIs without "Secure" or "Crypto" in its name
* A well seeded CSRPNG can produce unlimited output

### Key lifecycle and storage

* Base64 encoded keys are not encrypted
* Make sure to set file ACL appropriately when storing a secret key in a file
* Prefer using OS-API for key management to doing this manually
* Secret keys stored in a file should preferably be encrypted with a key derived from a user-supplied password
* Secret keys from a hardware token can usually not be exported
* Secret keys generated on a hardware token won't have a backup available
* All keys should have a well-defined lifetime and be rotated at the end of the lifetime
* Common lifetimes for certain key sizes can be found in industry recommendations
* The more often a key is used, the shorter its lifetime should be
* The shorter the size of a key, the shorter its lifetime should be
* Access to a key needs to be restricted according to the principle of least privilege
* When rotating a symmetric key, all data encrypted with the old key needs to be re-encrypted

### Digital signatures and HMACs

* MACs are symmetric algorithm
* Digital signatures are asymmetric algorithms
* When using a MAC, everyone who can verify a signature can also create one
* When using a digital signature, people who can verify a signature cannot create one
* A digital signature is created with a private key
* A digital signature is verified with a public key
* A MAC is created with a secret key
* A MAC is verified with a secret key
* MACs are faster the digital signatures
* Always verify the signature before using the signed data
* Elliptic curve based schemes have smaller key- and signature-sizes than RSA
* Prefer Ed25519 (EdDSA) over ECDSA
* (X.509) certificates combine a public key with metadata about the key's owner
* (X.509) certificates are digitally signed by a trusted entity
* X.509 certificates are digitally signed by Certification Authority (CA)

## Module 6: Error Handling  
        Logging sensitive operations securely  
        Avoiding stack traces/info leaks

## Module 7: Secure Logging  
        Log protection (tamper resistance)  
        Real-time alerting and monitoring

## Module 8: Data Protection and Privacy  
        TLS enforcement  
        Client-side storage threats  
        GDPR/CCPA considerations  
        Data retention and purging  
        Caching and privacy headers

## Module 9: Secure Communications  
        TLS 1.2+ best practices  
        HTTPS and HSTS  
        Certificate pinning  
        Secure protocol selection

## Module 10: Malicious Code, Supply Chain and Open Source Software  
        Dependency management (SCA tools like OWASP Dependency-Check)  
        Secure deserialization  
        Subdomain takeover  
        Code signing and verification  
        Open source software and licensing

## Module 11: Business Logic Security  
        Logical flaws (race conditions, inconsistent state)  
        Anti-automation (CAPTCHA, rate limiting)  
        Anomaly detection and misuse cases

## Module 12: Secure File and Resource Handling  
        Upload/download controls  
        Path traversal  
        RFI, SSRF protections  
        MIME sniffing and validation

## Module 13: API and Web Service Security  
        REST, GraphQL, and SOAP security models  
        Authentication and authorization for APIs  
        Throttling and abuse protection  
        JSON and XML parser safety

## Module 14: Secure Configuration and Deployment  
        Secure defaults  
        Secrets management (vaults, env vars)  
        CORS, CSP, HSTS  
        SBOM and CI/CD hardening

## Module 15: Security of and for AI  
        Securing models  
        Securing datasets

